/**
 * This package contains simple TypeScript types for working with SnarkJS,
 * plus utilities to convert from SnarkJS outputs to smart contract call data.
 *
 * ## Installation
 *
 * You can install this package using [`npm`](https://www.npmjs.com) or
 * [`yarn`](https://classic.yarnpkg.com/lang/en/) by running:
 *
 * ```bash
 * npm install --save @projectsophon/snarks
 * ```
 * ```bash
 * yarn add @projectsophon/snarks
 * ```
 *
 * When using this in a plugin, you might want to load it with [skypack](https://www.skypack.dev)
 *
 * ```js
 * import * as snarks from 'http://cdn.skypack.dev/@projectsophon/snarks'
 * ```
 *
 * @packageDocumentation
 */

/**
 * Type representing the shape that can be passed into smart contract
 * functions that require zkSNARK verification.
 */
export type ContractCallArgs = [
  [string, string], // proofA
  [
    // proofB
    [string, string],
    [string, string]
  ],
  [string, string], // proofC
  string[] // public signals
];

/**
 * A zkSNARK proof (without signals) generated by SnarkJS `fullProve`
 */
export type SnarkJSProof = {
  pi_a: [string, string, string];
  pi_b: [[string, string], [string, string], [string, string]];
  pi_c: [string, string, string];
};

/**
 * A zkSNARK proof and corresponding public signals generated by SnarkJS `fullProve`
 */
export type SnarkJSProofAndSignals = {
  proof: SnarkJSProof;
  publicSignals: string[];
};

/**
 * Function for converting the output of SnarkJS `fullProve` into a shape that can be
 * passed into smart contract functions which perform zk proof verification.
 *
 * @param snarkProof the SNARK proof
 * @param publicSignals the circuit's public signals (i.e. output signals and public input signals)
 * @returns The input data in a shape that is suitable to use as smart contract call data
 */
export function buildContractCallArgs(snarkProof: SnarkJSProof, publicSignals: string[]): ContractCallArgs {
  // the object returned by genZKSnarkProof needs to be massaged into a set of parameters
  // the verifying contract will accept
  return [
    snarkProof.pi_a.slice(0, 2), // pi_a
    // genZKSnarkProof reverses values in the inner arrays of pi_b
    [snarkProof.pi_b[0].slice(0).reverse(), snarkProof.pi_b[1].slice(0).reverse()], // pi_b
    snarkProof.pi_c.slice(0, 2), // pi_c
    publicSignals, // input
  ] as ContractCallArgs;
}

/**
 * Function to generate **mock** proof and signal data in the shape SnarkJS would return.
 *
 * Only useful if you are using a mock hash and ZK proofs are disabled
 *
 * @param publicSignals the circuit's public signals (i.e. output signals and public input signals)
 * @returns A mock proof and public signals in the shape of SnarkJS output
 */
export function mockProof(publicSignals: string[] = []): SnarkJSProofAndSignals {
  return {
    proof: {
      pi_a: ["0", "0", "0"],
      pi_b: [
        ["0", "0"],
        ["0", "0"],
        ["0", "0"],
      ],
      pi_c: ["0", "0", "0"],
    },
    publicSignals: publicSignals,
  };
}
